{
  "folders": [
    ".",
    "Sounds"
  ],
  "files": {
    "main.py": "import pygame\nimport sys\nfrom game import Game\nfrom colors import Colors\n\npygame.init()\ntitle_font = pygame.font.Font(None, 40)\n\n\nscreen = pygame.display.set_mode((500, 620))\npygame.display.set_caption(\"Python Tetris\")\n\nclock = pygame.time.Clock()\n\nGAME_UPDATE = pygame.USEREVENT\npygame.time.set_timer(GAME_UPDATE, 200)\n\ngame = Game()\n\nwhile True:\n    screen.fill(Colors.dark_blue)\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == pygame.KEYDOWN:\n            if game.game_over == True:\n                game.game_over = False\n                game.reset()\n            if event.key == pygame.K_LEFT and game.game_over == False:\n                game.move_left()\n            if event.key == pygame.K_RIGHT and game.game_over == False:\n                game.move_right()\n            if event.key == pygame.K_DOWN and game.game_over == False:\n                game.move_down()\n                game.update_score(0, 1)\n            if event.key == pygame.K_UP and game.game_over == False:\n                game.rotate()\n        if event.type == GAME_UPDATE and game.game_over == False:\n            game.move_down()\n    \n    game.draw(screen)\n    \n    pygame.display.update()\n    clock.tick(60)",
    "grid.py": "import pygame\nfrom colors import Colors\n\nclass Grid:\n    def __init__(self):\n        self.num_rows = 20\n        self.num_cols = 10\n        self.cell_size = 30\n        self.grid = [[0 for j in range(self.num_cols)] for i in range(self.num_rows)]\n        self.colors = Colors.get_cell_colors()\n\n    def print_grid(self):\n        for row in range(self.num_rows):\n            for column in range(self.num_cols):\n                print(self.grid[row][column], end=' ')\n            print()\n\n    def draw(self, screen):\n        for row in range(self.num_rows):\n            for column in range(self.num_cols):\n                cell_value = self.grid[row][column]\n                cell_rect = pygame.Rect(column * self.cell_size + 11, row * self.cell_size + 11, self.cell_size - 1, self.cell_size - 1)\n                pygame.draw.rect(screen, self.colors[cell_value], cell_rect, 0, 0)\n\n    def is_inside(self, row, column):\n        if row >= 0 and row < self.num_rows and column >= 0 and column < self.num_cols:\n            return True\n        return False\n    \n    def is_empty(self, row, column):\n        if self.grid[row][column] == 0:\n            return True\n        return False\n\n    def is_row_full(self, row):\n        for column  in range(self.num_cols):\n            if self.grid[row][column] == 0:\n                return False;\n        return True\n    \n    def clear_row(self, row):\n        for column  in range(self.num_cols):\n            self.grid[row] [column] = 0\n\n    def move_row_down(self, row, num_rows):\n        for column in range(self.num_cols):\n            self.grid[row+num_rows] [column] = self.grid[row][column]\n            self.grid[row][column] = 0\n    \n    def clear_full_rows(self):\n        completed = 0\n        for row in range(self.num_rows-1, 0, -1):\n            if self.is_row_full(row):\n                self.clear_row(row)\n                completed += 1\n            elif completed > 0:\n                self.move_row_down(row, completed)\n        return completed\n    \n    def reset(self):\n        for row in range(self.num_rows):\n            for column in range(self.num_cols):\n                self.grid[row][column] = 0",
    "block.py": "import pygame\nfrom colors import Colors\nfrom position import Position\n\nclass Block():\n    def __init__(self, id):\n        self.id = id\n        self.cells = {}\n        self.cell_size = 30\n        self.rotation_state = 0\n        self.row_offset = 0\n        self.column_offset = 0\n        self.color = Colors.get_cell_colors()\n\n    def move(self, rows, columns):\n        self.row_offset += rows\n        self.column_offset += columns\n\n    def get_cell_positions(self):\n        moved_tiles = []\n        tiles = self.cells[self.rotation_state]\n        for position in tiles:\n            position = Position(position.row + self.row_offset, position.column + self.column_offset)\n            moved_tiles.append(position)\n        return moved_tiles\n    \n    def rotate(self):\n        self.rotation_state += 1\n        if  self.rotation_state == len(self.cells):\n            self.rotation_state = 0\n\n    def undo_rotation(self):\n        self.rotation_state -= 1\n        if  self.rotation_state == 0:\n            self.rotation_state = len(self.cells) - 1\n\n    def draw(self, screen, offset_x, offset_y):\n        tiles = self.cells[self.rotation_state]\n        for tile in tiles:\n            tile_rect = pygame.Rect(offset_x + tile.column * self.cell_size, offset_y + tile.row * self.cell_size , self.cell_size - 0, self.cell_size -0)\n            pygame.draw.rect(screen, self.color[self.id], tile_rect, 0,0)",
    "colors.py": "class Colors:\n    dark_grey = (21, 21, 30)\n    green = (61, 179, 93)\n    red = (237, 90, 90)\n    orange = (255, 147, 61)\n    yellow = (255, 217, 61)\n    purple = (173, 84, 198)\n    cyan = (55, 214, 227)\n    blue = (63, 111, 245)\n    white = (255, 255, 255)\n    dark_blue = (44, 44, 127)\n    light_blue = (59, 85, 162)\n\n    @classmethod\n    def get_cell_colors(cls):\n        return [cls.dark_grey, cls.green, cls.red, cls.orange, cls.yellow, cls.purple, cls.cyan, cls.blue]",
    "position.py": "class Position:\n    def __init__(self, row, column):\n        self.row = row\n        self.column = column",
    "blocks.py": "from block import Block\nfrom position import Position\n\nclass IBlock(Block):\n    def __init__(self):\n        super().__init__(1)\n        self.cells = {\n            0: [Position(1, 0), Position(1, 1), Position(1, 2), Position(1, 3)],\n            1: [Position(0, 2), Position(1, 2), Position(2, 2), Position(3, 2)],\n            2: [Position(2, 0), Position(2, 1), Position(2, 2), Position(2, 3)],\n            3: [Position(0, 1), Position(1, 1), Position(2, 1), Position(3, 1)]\n        }\n        self.move(-1, 3)\n\n\nclass JBlock(Block):\n    def __init__(self):\n        super().__init__(2)\n        self.cells = {\n            0: [Position(0, 0), Position(1, 0), Position(1, 1), Position(1, 2)],\n            1: [Position(0, 1), Position(0, 2), Position(1, 1), Position(2, 1)],\n            2: [Position(1, 0), Position(1, 1), Position(1, 2), Position(2, 2)],\n            3: [Position(0, 1), Position(1, 1), Position(2, 0), Position(2, 1)]\n        }\n        self.move(0, 3)\n\n\nclass LBlock(Block):\n    def __init__(self):\n        super().__init__(3)\n        self.cells = {\n            0: [Position(0, 2), Position(1, 0), Position(1, 1), Position(1, 2)],\n            1: [Position(0, 1), Position(1, 1), Position(2, 1), Position(2, 2)],\n            2: [Position(1, 0), Position(1, 1), Position(1, 2), Position(2, 0)],\n            3: [Position(0, 0), Position(0, 1), Position(1, 1), Position(2, 1)]\n        }\n        self.move(0, 3)\n\n\nclass OBlock(Block):\n    def __init__(self):\n        super().__init__(4)\n        self.cells = {\n            0: [Position(0, 0), Position(0, 1), Position(1, 0), Position(1, 1)]\n        }\n        self.move(0, 4)\n\n\nclass SBlock(Block):\n    def __init__(self):\n        super().__init__(5)\n        self.cells = {\n            0: [Position(0, 1), Position(0, 2), Position(1, 0), Position(1, 1)],\n            1: [Position(0, 1), Position(1, 1), Position(1, 2), Position(2, 2)],\n            2: [Position(1, 1), Position(1, 2), Position(2, 0), Position(2, 1)],\n            3: [Position(0, 0), Position(1, 0), Position(1, 1), Position(2, 1)]\n        }\n        self.move(0, 3)\n\n\nclass TBlock(Block):\n    def __init__(self):\n        super().__init__(6)\n        self.cells = {\n            0: [Position(0, 1), Position(1, 0), Position(1, 1), Position(1, 2)],\n            1: [Position(0, 1), Position(1, 1), Position(1, 2), Position(2, 1)],\n            2: [Position(1, 0), Position(1, 1), Position(1, 2), Position(2, 1)],\n            3: [Position(0, 1), Position(1, 0), Position(1, 1), Position(2, 1)]\n        }\n        self.move(0, 3)\n\n\nclass ZBlock(Block):\n    def __init__(self):\n        super().__init__(7)\n        self.cells = {\n            0: [Position(0, 0), Position(0, 1), Position(1, 1), Position(1, 2)],\n            1: [Position(0, 2), Position(1, 1), Position(1, 2), Position(2, 1)],\n            2: [Position(1, 0), Position(1, 1), Position(2, 1), Position(2, 2)],\n            3: [Position(0, 1), Position(1, 0), Position(1, 1), Position(2, 0)]\n        }\n        self.move(0, 3)",
    "game.py": "import pygame\nimport random\nfrom grid import Grid\nfrom blocks import *\n\nclass Game:\n    def __init__(self):\n        self.grid = Grid()\n        self.blocks = [IBlock(), JBlock(), LBlock(), OBlock(), SBlock(), TBlock(), ZBlock()]\n        self.current_block = self.get_random_block()\n        self.next_block = self.get_random_block()\n        self.game_over = False\n        self.score = 0\n        pygame.mixer.music.load('Sounds/music.ogg')\n        pygame.mixer.music.play(-1)\n        self.rotate_sound = pygame.mixer.Sound('Sounds/rotate.ogg')\n        self.clear_sound = pygame.mixer.Sound('Sounds/clear.ogg')\n\n    def get_random_block(self):\n        if len(self.blocks)==0:\n            self.blocks = [IBlock(), JBlock(), LBlock(), OBlock(), SBlock(), TBlock(), ZBlock()]\n\n        block = random.choice(self.blocks)\n        self.blocks.remove(block)\n        return block\n    \n    def rotate(self):\n        self.current_block.rotate()\n        if self.block_inside() == False or self.block_fits() == False:\n            self.current_block.undo_rotation()\n\n    def move_left(self):\n        self.current_block.move(0, -1)\n        if self.block_inside() == False or self.block_fits() == False:\n            self.current_block.move(0, 1)\n\n    def move_right(self):\n        self.current_block.move(0, 1)\n        if self.block_inside() == False or self.block_fits() == False:\n            self.current_block.move(0, -1)\n\n    def move_down(self):\n        self.current_block.move(1, 0)\n        if self.block_inside() == False or self.block_fits() == False:\n            self.current_block.move(-1, 0)\n            self.lock_block()\n\n    def block_inside(self):\n        tiles = self.current_block.get_cell_positions()\n        for tile in tiles:\n            if self.grid.is_inside(tile.row, tile.column) == False:\n                return False\n        return True\n\n    def block_fits(self):\n        tiles = self.current_block.get_cell_positions()\n        for tile in tiles:\n            if self.grid.is_empty(tile.row, tile.column) == False:\n                return False\n        return True\n\n    def lock_block(self):\n        tiles = self.current_block.get_cells_positions()\n        for position in tiles:\n            self.grid.grid[position.row][position.column] = self.current_block.id\n        self.current_block = self.next_block\n        self.next_block = self.get_random_block()\n\n        if self.block_fits() == False:\n            self.game_over = True\n    \n    def reset(self):\n        self.grid.reset()\n        self.blocks = [IBlock(), JBlock(), LBlock(), OBlock(), SBlock(), TBlock(), ZBlock()]\n        self.current_block = self.get_random_block()\n        self.next_block = self.get_random_block()\n        self.score = 0\n\n    def draw(self, screen):\n        self.grid.draw(screen)\n        self.current_block.draw(screen, 11, 11)\n        if self.next_block.id == 1:\n            self.next_block.draw(screen, 255, 290)\n        elif self.next_block.id == 4:\n            self.next_block.draw(screen, 255, 280)\n        else:\n            self.next_block.draw(screen, 270, 270)\n\n    def update_score(self, lines_cleared, move_down_points):\n        if lines_cleared == 1:\n            self.score += 100\n        elif lines_cleared == 2:\n            self.score += 300\n        elif lines_cleared == 3:\n            self.score += 500\n\n        self.score += move_down_points"
  }
}