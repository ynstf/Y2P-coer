Get ready to embark on an epic game development journey and recreate the most popular game ever created - Tetris! With just a few hours of your time, you'll be able to create your very own fully functional and engaging Tetris game using Python and Pygame. Join me as I take you step-by-step through the process, from setting up the game loop to creating the game grid and blocks, to implementing movement, collision detection, and scoring. You'll learn invaluable game development concepts and techniques along the way, and by the end of this tutorial, you'll have a polished and exciting Tetris game that you can proudly share with the world! To make sure you don't miss out on any updates and new tutorials, be sure to subscribe to my channel and hit that like button to show your support. So, what are you waiting for? Let's dive into the world of Tetris game development together! Subscribe now and let's get started! But why build Tetris on your own if tools like ChatGPT can build it for you in seconds? In today's world of constant distractions, shortened attention spans, and easy access to AI tools, it's important to develop the ability to focus on a complex task and see it through to completion. Building a game like Tetris from scratch will challenge you to break down a complex problem into manageable steps, strengthen your problem-solving skills, and improve your ability to concentrate on a project from start to finish. Today there are so many distractions vying for our attention, from social media notifications to instant messaging, that it can be difficult to concentrate on any one task for an extended period of time. However, the ability to concentrate is crucial for success in any field, including game development. Without focus, it's easy to become overwhelmed by the complexity of a project like Tetris and give up before completing it. By practicing focus and building the game from scratch, you can strengthen this vital skill and become better equipped to tackle any challenge that comes your way. Not to mention the satisfaction that comes with creating something entirely from your own ideas and hard work. I promise you, If you complete this tutorial, you are going to feel very happy. Trust me. Also, learning to build a Tetris game using Python and Pygame is a great way to improve your coding skills and expand your knowledge of game development. By following this tutorial, you will be able to learn the fundamentals of Python programming, such as loops, conditionals, functions, and object-oriented programming. You will also gain experience with Pygame, a powerful library for building 2D games in Python. To fully benefit from this Tetris game tutorial, it is recommended that you have a basic understanding of Python programming. If you're new to Python, consider watching my Python for Absolute Beginners course first, which can be found in the video description or in this card. Additionally, if you're new to game development with Pygame, I suggest starting with our Pong and Snake game tutorials, also linked in the video description, to make the learning process smoother. Don't worry if you're not yet an expert in Python or Pygame – this tutorial will provide valuable insights and help you learn a lot. As Lao Tzu once said, 'The journey of a thousand miles begins with a single step.' So let's take that first step towards creating our own Tetris game and see where this journey takes us! Tetris may seem complex and challenging to develop, but fear not! We'll take a divide and conquer approach to make it more manageable. In this tutorial, we'll break the development process down into 13 steps, tackling each one individually and building upon what we've accomplished in previous steps. With this approach, you'll be well on your way to creating your own Tetris game in no time! Steps Install Pygame Setup gameloop Create the grid Create the blocks Move the blocks Rotate the blocks Check for collisions Check for completed rows Game Over Create UI Add Score Add Next Block Add Sounds So, let's get started and see how we can conquer this challenging project one step at a time! The first step is to install pygame. Pygame is a Python library used to create games and multimedia applications. In this tutorial, we'll be using the pygame community edition, a fork of the original pygame library that is regularly updated with new features and bug fixes. However, you can also use the standard pygame library if you prefer, as the code we'll be using is exactly the same. To install the pygame-ce library, all we have to do is to open a terminal window and type the following command: pip install pygame-ce With the Pygame library installed, we can now verify that it's working correctly by running a simple test script. To do this, we create a new folder, we create a new Python file in it and we name it "main.py". Now we can open this file with our favorite editor. I will be using Sublime text in this tutorial. Inside the file, we have to import Pygame by typing: import pygame. Next, we have to run the program to see if Pygame is installed correctly. In Sublime text simply press Ctrl+ B to run the program. If you see the message “pygame-ce”, our installation is working fine and we have successfully completed step #1. That was easy, wasn't it? We're one step closer to our goal of building a fully-functional Tetris game. Let's move on to step #2. The next step in building our Tetris game is to create a blank screen and set up the game loop. Before we start, it's important to understand the structure of a game. Every game consists of two parts: the part where we define our variables and game objects, such as the Grid, the blocks, and the UI; and the game loop, which is responsible for updating the positions of the game objects and checking for collisions. The game loop is like the heartbeat of the game, running repeatedly until the game is closed. In each iteration of the game loop, we'll draw the game objects in their new positions and check for collisions, all happening so fast that it appears as a continuous movement. Now let’s create a blank screen and the game loop. First of all we need to initialise pygame so we type: pygame.init() Then we create a display surface. A display surface is like a blank canvas where we can draw our game objects. We need to specify the width and the height of the display surface. I am going to use a size of 300 x 600 pixels for now. We will change that later. Let’s create the display surface. screen = pygame.display.set_mode((300, 600)) This line of code creates a display surface object named screen.The set_mode() method takes a tuple as an argument. The first value is the width and the second value is the height of the display surface, our canvas. In simpler terms, we just created the game window and to draw on it, we use a coordinate system similar to the one taught in high school. Each point on this window has its unique x and y values. The coordinate system used in computer graphics differs from the standard Cartesian coordinate system taught in high school. In computer graphics, the origin of the display is located at the top-left corner, with (0,0) being at the top-left. In contrast, the standard Cartesian coordinate system starts from the bottom-left corner, with (0,0) being the origin. In this system, the x-coordinate increases as we move to the right and the y-coordinate increases as we move up. However, in the top-left corner coordinate system used in computer graphics, the x-coordinate increases as we move to the right and the y-coordinate increases as we move down. This means that a point at (10, 10) would be located 10 units to the right and 10 units down from the origin. We'll be using the top-left corner coordinate system in our Tetris game. That’s why it's important to understand the differences between these two coordinate systems, Now that we have created the screen we need to give it a title. We do that by using the set_caption() function: pygame.display.set_caption(“Python Tetris”) Next we create a clock object like this: clock = pygame.time.Clock() . Be careful we need a capital C here. We need this clock object to control the frame rate of the game, how fast the game will run. Don’t worry about this line of code now, we will get back to it in a minute. The basic setup of the game is now complete. Let’s now work on the game loop. The game loop consists of three parts. Event handling: First, we need to check for any events that occur in the game, such as quitting the game, a key pressed on the keyboard, etc. This is done using the Pygame event handling system. Updating positions: Next, we update the positions of all game objects, the blocks, based on the events we detected in step 1. Drawing objects: Finally, we draw all the game objects in their new positions on the screen. This step uses the Pygame graphics functions to render the objects in the display. By following these three steps, we can create a dynamic and interactive game that responds to user inputs and updates its state accordingly. We start the game loop with a while loop like this: while True: The while loop is an essential part of our Tetris game. It runs continuously until we close the game. At each iteration of the loop, we perform three key steps: checking for events, updating positions of game objects, and drawing the game objects in their new positions. It's important to note that before running the game, we need to ensure that the code inside the while loop has been fully written. If we run the code at this point, the while loop will run indefinitely since we have not defined a way to stop its execution. So, in the next step, we'll add the necessary code to stop the while loop. for event in pygame.event.get(): This line of code gets all the events that pygame recognizes and happened since the last time the while loop ran and puts them in a list. Then we loop through the list of events and check if any of the events is the QUIT event. The QUIT event is when we click on the close button of the window. If the event is the QUIT event we break out of the while loop. if event.type == pygame.QUIT: pygame.quit() and then we have to close the program completely with the command sys.exit(). This command is part of the sys module, so we have to import it like this. In the first line of the code after importing pygame we type coma, sys. That’s it. Now we have defined a way to exit the game, but we need a couple more lines of code before running our game for the first time. We have to update the screen with this line of code pygame.display.update() This line of code takes all the changes we made in the game objects and draws a picture from them. Since we haven’t created any game objects yet this line just draws a black screen. Remember the clock object we created in the beginning? We need to use it now. We have to tell the clock object how fast the game should run. We do that by using the tick() method. The tick() method takes an integer as an argument and that integer is the number of frames per second that we want. I am going to use 60 frames per second. clock.tick(60) That’s it. This means that the while loop, and all the code inside it, will run 60 times every second. If we didn't set a frame rate, the game would run as fast as the computer can handle, which could lead to inconsistencies in the game's speed. By setting the frame rate, we make sure that the game runs smoothly and at the same speed for all players. Now that the game loop is complete we can run the game for the first time. If we run the game at this point we won’t see anything inside the game window because we haven’t drawn anything yet. But, the important thing is that we can see the game window with the title and the dimensions we defined and that we can reliably close the game by clicking on this X icon here. Beautiful. The game window is black let’s make it a dark blue color. Pygame provides several built-in colors, but we will be defining our own colors for this game. In Pygame, colors are represented as a tuple of three values, each value representing the amount of red, green, and blue in the color. The values for each component range from 0 to 255, where 0 represents the absence of the color and 255 represents the full intensity of the color. For example, to create a red color, we would create a tuple with the following values: red = (255, 0, 0) These values represent the red, green, and blue components, respectively. So, to create a dark blue color we will create a tuple like this: dark_blue = (44, 44, 127) Now, let’s paint the game screen dark_blue. Inside the game loop, before updating the screen we call the fill method of the screen object like this. screen.fill(dark_blue) The fill method just fills the display surface we have created, our canvas with the color we define, in this case, dark_blue. If we run the game now, we can see the game window is now dark_blue. Beautiful. We just completed a very basic game loop, so we can remove step #2 from our list. We have made progress. Now let’s work on Step #3. To prepare for writing code, it's important to take a step back and think through the game logic thoroughly. In Tetris, the gameplay area is a grid consisting of 20 rows and 10 columns. The game pieces, or "tetrominoes," fall down the grid and the player must arrange them to form complete rows without any gaps. We will count the rows from top to bottom and the columns from left to right, with the top left cell at row 0 and column 0 being the origin. To represent the grid we will use a two-dimensional array which can be implemented as a list of lists in Python. In our implementation, empty cells will be represented by the value 0. When a tetromino, a block, is permanently placed on the grid by the player, the corresponding cells will be assigned a value reflecting its color. For example, if we place a red tetromino on the grid, we will assign the value 2 to the cells it covers. Similarly, if we place a yellow block, we will assign the value 4 to its corresponding cells. Each color has a unique numerical value, and since there are 7 different colors in the game, the values used in the 2D array will range from 0 to 7. 0 for an empty cell, and 1 to 7 for the colors of the blocks. So, if the game state at some point is something like this, the 2 dimensional array will look like this. However, the current block that can still be controlled by the player will not be reflected in the array, and will instead be stored and managed separately in the game logic. Now that we have a clear understanding of the game grid, we can begin implementing it in code. Let’s go back to our code. We are going to use Object Oriented programming to help us organize our code. We will create a Grid class. Let’s create this class in a separate window. I press Ctrl+N to create a new file and then Ctrl+S to save it as grid.py. Now we can start writing our Grid class. We type: class Grid: Now let’s create the init method which will initialize the grid object. What do we want to know about the grid? First we need to know how many rows and how many columns it contains. So, let’s create two attributes to store this information. Def __init__(self): self.num_rows = 20 Self.num_cols = 10 Next, we need to know the size of each cell of the grid in pixels. Let’s make each cell 30 pixels in width and height. Self.cell_size = 30 Now we need a 2 dimensional array to represent the grid itself. As we said we are going to use a list of lists to represent a 2 dimensional array. So let’s create that list. Self.grid = [[]] Now, we have to fill that list of lists with zeros. One way to do it is this one. I now have a list of lists that each contains 10 zeros. This is a representation of our grid, filled with zeros. But creating the list like this requires a lot of space in the file and is tedious. We programmers don’t like to repeat things manually, we like to automate things. We can do the same thing with just a single line of code. Check this out: self.grid = [[0 for j in range(self.num_cols)] for i in range(self.num_rows)] This line is called a list comprehension. It's a shorthand way to create a list of lists, or a 2D list. The inner part [0 for j in range(self.num_columns)] creates a list of zeros with length equal to self.num_columns, in our case 10 zeros. This is done self.num_rows times because it's wrapped in another list comprehension, which repeats this process for self.num_rows times, for 20 times. So the resulting list is a 2D list with self.num_rows rows and self.num_cols columns, where each cell is initialized to 0. Cool huh. Let’s print this grid at the terminal to see if it works. Let’s create a method for it. Def print_grid(self): for row in range(self.num_rows): for column in range(self.num_cols): print(self.grid[i][j], end=' ') print() This code iterates over every cell in the grid and prints out its value, row by row, with each row printed on a new line. This method will be useful if we want to see the state of our grid later on. Let’s now create a grid object in the main file and print it to see if everything works as expected. I can press ALT+1 and Sublime text will get me back to the first open tab, our main.py file. Now we have to import the Grid class from the grid.py file. From grid (that’s the file name) import Grid (that’s the class name). Now we can create a grid object. We type game_grid = Grid() Now we can call the print_grid() method. game_grid.print_grid() And now let’s run the program! Cool! As you can see at the terminal we can see all the contents of the grid. A 2d array filled with zeros! Our grid is ready. Now let’s go back to the Grid class to work on it a little more. ALT+2 and sublime text get me back to the Grid class. ------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------ What else do we want the grid to know about? The grid must also know the colors to use to display each cell. So, let’s create a list to hold all the colors it will use. self. colors = As we said we have 7 blocks in the tetris game and each block has its unique color. So we are going to need 7 colors for the cells of the blocks and one color for the empty cell, a dark grey color. Let’s create a method that will return a list of 8 colors. Def get_cell_colors(): Now let’s create the colors. As we said, a color is just a tuple of three values. So, let’s create the tuples … Here are all the colors. I have created a tuple for each color and tuple for the color of the empty cell, this one. Now let’s put all of them in a list and return that list. Return [dark_grey, green, red, orange, yellow, purple, cyan, blue] The order of the list is important. We are going to use the index of each color later on when we draw each cell on the screen. The index corresponds to the block id, but more on that in a minute. So now in the init method we can now load the list of colours. Self.colors = self.get_cell_colors(). That’s it. The init method of the grid class is ready. Now we are ready to draw the grid. Let’s create a draw method. def draw(self): We need to draw each cell of the grid with a specific color. With dark grey_color if the cell contains 0, with green color if the cell contains the value 1 and so on. So, first we have to get the value stored in each cell of the grid. We will use a nested for loop for this: For row in range(self.num_rows): For column in range(self.num_cols): cell_value = self.grid[row][column] This code iterates through each cell in the grid, and assigns the value of that cell to the variable "cell_value". Now it is time to draw this cell on the screen and give it a color. Now, before we draw something let’s talk about how pygame draws on the screen.We have three basic concepts to learn, the display surface, the regular surface, and the rect. The display surface is the surface where we see all the game objects. It's like the blank canvas we talked about before. The display surface is created when we call the set_mode() function and it's the object we use when we call the update() function. A regular surface is a surface like the display surface that we can draw on it. We can have as many surfaces as we want in a game, unlike the display_surface which we can only have one per game. We are going to use surfaces to draw text on the display surface later on. A rect is a rectangular area. It has a position and a size. We use rects for the collision detection, easy manipulation of objects and for easy drawing on a surface as you are going to find out in a minute. Now that we know the basics of how drawing works in pygame let's draw our first object, a cell of the grid. First of all we have to create a rect to contain the cell. This rectangle will be invisible but it will help us draw the cell on the screen. So we type: cell_rect = pygame.Rect(x, y, w, h) We need to know 4 things to create the Rect object. The x and y coordinate of its top left corner, its width and its height. The x is going to be column but since we are using a grid we have to multiply this by the self.cell_size. We do the same thing for the y. row*self.cell_size. Now the width is going to be cell_size, and the height is also going to be cell_size. Cool. Now we can draw the cell. We are going to draw it as a square. We are going to call the pygame.draw.rect method. Before using this method we first need to import the pygame module, so at the beginning of our Grid class we import pygame. The pygame.draw.rect method requires 3 arguments. The surface to draw the object on, a color, and a rect. We have everything we need. The surface we are going to draw on is the display surface we created in the main.py file, named screen. Since we are in the Grid class, and not in the main.py file we have to pass the display_surface named screen as an argument to the method, so we type screen here. The color is the color stored at the colors list. But which one? We can use the cell_value to index into the colors list and retrieve the color tuple for that specific cell. so we type self.colors[cell_value]. Since our grid now only contains zeros, the cell_value variable will be 0, so this will return the first color of the list, which is a dark_grey color. Then we have to tell the Draw function that the rect we want to draw is the cell_rect. That’s it. Our draw method is ready. Let’s use it in our code. Let’s go back to the main file and call the draw method of the grid object we have created inside the main loop. So, after the screen.fill method we type: game_grid.draw() and we pass in the screen display surface. Let’s run the program. When we run the game, we see a grey screen because all the cells are the same grey color and there is no visible space between them. To make the cells visible, we need to add a margin of 1 pixel to each cell. Our cell size is 30x30 pixels, so we can draw a 29x29 pixels grey rectangle for each cell to create the margin. This way, the grid lines will be visible, making the game more understandable and easier to play. Let’s do it. In the draw method of the grid class, in the draw rect method we need to make some changes. We need to add +1 here and here. This way we add a 1 pixel offset at the x and y position of the grey rectangle we are drawing. Also we need to subtract 1 pixel from the width and the height of the rectangle we draw because we said we need it to be 29 pixels. That’s it. If we run the game once more, we can see that the grid lines are now visible! Beautiful! Our grid is visible. Now, let’s modify the values of some cells to see if our grid can display them in different colours. So, outside of the game loop let’s hardcode the values of some cells as a test for our grid class. Let's set some values in the grid. Firstly, we'll make the top left cell hold the value 1. game_grid.grid[0][0] = 1 I can duplicate this line by pressing Ctrl+Shift+D. Next, let's make the cell at the 4th row and 6th column hold the value 4, and the cell at the 18th row and 9th column hold the value 7. It's important to note that counting for rows and columns starts from 0, so the 4th row is actually the row with index 3. Let’s run the game again to see the changes we made. Great! Now we can see that the cells are displayed with different colors, indicating that the game is functioning as expected. Additionally, we can check the console to see the values of each cell, including the ones we have just changed in the code. Perfect! We have just completed step #3. Congratulations on making it this far in the tutorial! You're doing great! Let's keep going and continue building our Tetris game. The next step is to create the blocks of the game. As you know Tetris is a game where you have to fit different shapes made of four tiles each. There are seven types of shapes in total called tetrominoes. When you start the game, the blocks appear in a certain way. The blocks in Tetris can spin around a point, usually in the middle of one of their tiles. For instance, the T-shaped block rotates around the center tile. The I block and O block in Tetris rotate differently than the other blocks. The I block rotates around a point that isn't in the center of a tile, while the O block doesn't appear to rotate at all. To represent the blocks, we imagine a box around each block that's big enough to fit it in all four rotation states. The box is divided into a grid, and we label the top left cell as the origin (row 0, column 0), just like in the game grid. For each of the four rotation states, we store which cells are occupied in this grid, not all the cells of the grid. Let's use an example to make this clearer. Imagine the T-block in Tetris. We draw a box around it and divide it into a grid with 3 rows and 3 columns, making 9 cells in total. However, we only need to store the cells that the T-block occupies, not the whole grid. If the T-block is in its first state (state 0), we only need to store the values (0, 1), which means that the cell in row 0 and column 1 is occupied. We also need to store (1, 0), (1, 1), and (1, 2) for the other occupied cells. We repeat this process for the T-block's remaining three rotation states, storing only the occupied cells for each. This is how we represent all the blocks in Tetris, using this same process for each one. Using the bounding grid approach to represent the blocks has a big advantage: it makes rotating the blocks much easier. To rotate a block, all we need to do is to update a state variable that indicates the current rotation state of the block, and modify the occupied cells stored in the grid accordingly. This means we don't have to calculate the new positions of each tile in the block, which can be complex and time-consuming. Instead, we simply update the occupied cells in the bounding grid, and the game engine takes care of displaying the block in the correct rotated state. OK, now that we know how to represent each block using the bounding grid approach, let's return to our code and start implementing it. Now, before we start coding, let's leverage an object-oriented feature to simplify our code: inheritance. Inheritance is like passing down traits from parents to children. In Python, it allows us to create a new class that is a modified version of an existing class. The new class, called the child class, will inherit all the attributes and methods of the original class, called the parent class. Then, we can add new attributes and methods or override the inherited ones in the child class to customize its behavior. This way, we don't have to repeat the same code for similar classes, and we can make changes to the parent class that will affect all the child classes. It's like having a template that we can reuse and modify without starting from scratch every time. In this game, we have 7 different blocks, but they all share some common properties and behaviors. Instead of creating separate classes for each block and duplicating the same code, we can create a base block class with the shared code and characteristics, and then create 7 new classes for each block that inherit from the base class. This means that each of the new classes will automatically have all the properties and behaviors of the base class, without needing to repeat the code. Using inheritance helps us to simplify our code and make it more efficient. Even if you haven't used inheritance before, it's not a problem. It's actually a simple and powerful feature of object-oriented programming. Once you understand how it works in this game, you'll be able to apply it to other projects as well! Let's start by creating the Block class, the base class for all the blocks. Let’s create a new file and call it block.py. Now we type: class Block(): Def __init__(self): To create a block class, we need to determine what information each block needs to store. The most important thing is to distinguish between different blocks, so each block will have a unique id. To add this attribute, we can create an "id" attribute in the class self.id = id We need to pass this id as an argument in the init method. To represent the cells that the block occupies in a 4x4 grid for all rotation states, we will create an attribute called cells. Self.cells = This attribute will be a dictionary, so we initialize it with an empty set of curly braces {}. We will use this dictionary to store the occupied cells in the bounding grid for each rotation state of the block. A dictionary in Python is a collection of key-value pairs, where each key is unique and maps to a corresponding value. If you're not familiar with dictionaries in Python, don't worry! I have a detailed video explaining everything you need to know. You can watch it by clicking on this card. Next, we need to know the size of each cell of the block in pixels. Let’s make each cell 30 pixels in width and height. Self.cell_size = 30 The next thing we need to know is the rotation state of the block. So, let’s create a new attribute named rotation_state and set it to 0. self.rotation_state = 0 The last thing we need to know for the block, for now, is the colors it has to use to draw each occupied cell on the screen. The colors are the same ones we used in the grid class earlier. So, we can copy the method from the grid class and paste it in the block class. However, this will result in duplicate code, which is not a good programming practice. We want to avoid duplicate code as much as possible to keep our code organized and easy to maintain. So we will create another class to hold all the colors and use it in both the grid and block classes. This class will be called Colors and it will have attributes for each color we need in the game. Let’s do it. We press ctrl + N to create a new file and ctrl + S to save it as colors.py. Let’s create the Colors class. Class Colors: Now all we have to do is to paste the color definitions. We copy and paste them from the grid class. To make our lives easier, let’s create a method for this class that will return a list containing these colors in the specific order we want them. Let’s learn something new now. We are going to type the following. @classmethod @classmethod is a Python decorator that allows you to define a method that can be called on a class rather than on an instance of the class. Now we can create the method we want. def get_cell_colors(): We also need to pass in cls here. This way we can access the attributes of the class. cls is a reference to the class itself and it allows us to access the class-level attributes and methods. It's similar to using self to access instance-level attributes and methods, but cls is used for the class-level So now all we have to do is to return a list with all the colors we need for the cells, just like we did in the grid class. So let’s copy the return statement from the grid to the colors class. We just have to add cls. before each color definition to get these colors values. That’s it, our Colors class is ready and we can use it at once. First of all, let’s use the Color class in the grid class. Let’s import it. From colors import Colors Now, we don’t need the get_cell_colors() method any more so we can remove it. In the init method we just have to call the get_cell_colors() of the Colors class like this. Colors.get_cell_colors() Our grid class is ready. Let’s go back to the main file and run our program again to see if everything works. Cool! Our game works with the new colors class just like before. Now let’s go back to the block class. First we are going to import the Colors class. From colors import Colors As we said before we need a colors attribute, let’s create it. Self.color = Colors.get_cell_colors() That’s it. We now have a list of all the colors we need to use to draw a block on the screen. The block class will have a draw method that will be responsible for drawing the block on the screen. Let's create this method. Def draw(self, ) we need to know the surface we are going to draw on, so we well pass it in as an argument , screen): Now we need the position of each occupied cell of the block in order to draw it on the screen. But we don’t have this information yet. So, we have to create it. To make our lives easier let’s create a new class named position. The Position class will be helpful because it will allow us to represent a position in a two-dimensional grid using a single object. So we are going to create a new python file named position.py And now let’s create the Position class which will have only two attributes, row and column. Class Position: Def __init__(self): we need to pass in the row and the column in the constructor, so we type ,row, column here And now let’s create the row and column attributes Self.row = row And Self.column = column Cool, the position class is ready and now we can represent a position on the grid with a single object. To simplify our code, we will use inheritance. We'll create a separate class for each block, which will contain the cell positions for each rotation state. These classes will inherit from the block class. Let’s create a new file and let’s name it blocks.py. Inside this file we will create all the child classes, one for each block. First of all let’s import the two required classes. From block import Block From position import Position Now let’s create a class for the L tetromino. Class LBlock(): As we said this block must inherit the attributes and methods of the Block class. So we have to declare that inside the parenthesis. Block here. Now the LBlock class is a child of the block class. Now let’s create the init method. Def __init__(self): We need to initialize the Block class. So we have to call the init method of the Block class. We do this with this line of code. super().__init__() The Block constructor requires an id. Let’s give this block the id 1, or for better readability id = 1. Now, all we have to do is declare which cells are occupied. We are going to use the cells attribute of the block class. self.cells = { } As we said, the cells attribute is going to be a dictionary. The key of this dictionary will be the rotation state, a value from 0 to 3. So the dictionary is going to have 4 keys. Let’s do it. 0: 1: 2: 3: Now the value of each key will be a list containing the positions of the occupied cells, 4 cells for each block. Which cells are occupied when the I block is at the rotation state 0? Cells 0,0 , 1,0 , 1,1 and 1,2 Let’s create a list with these cells using the Position class. [ Position(0,0), Position(1, 0), Position(1,1), Position(1,2)] and a comma, That’s it. The rotation state 0 is ready. Now we need to do the same thing for the other three rotation states. I will leave this as an exercise for you to practice. Based on the given graphic, please fill in the missing data. Take your time to work on it, and when you're ready, you can resume the video to see the solution. Welcome back! I hope you were able to successfully complete the exercise and that it helped you better understand what we are doing. So, that’s the complete class. I have filled in all the data for all the rotation states. We have to do the same for all the blocks. But before that, let’s draw the first shape on the screen. Let’s go back to the block class and work on the draw method. Now we have access to all the cells of the block, for every rotation state. Check this out: tiles = self.cells[self.rotation_state] This line retrieves the list of positions for the current rotation state of the tetromino, as determined by the value of the self.rotation_state attribute. Now for each cell we can draw a rectangle, we are going to use a for loop for tile in tiles: Now we need to create a rectangle for each cell. For this we are going to use the pygame.Rect method so let’s import pygame. Import pygame here. Now let’s create the rectangle. I Tile_rect = pygame.Rect( ) tile.column * self.cell_size + 1, tile.row * self.cell_size + 1, self.cell_size - 1, self.cell_size -1 As we did in the grid class we leave a one pixel offset when we draw the cells. Now it is time to draw the cell. pygame.draw.rect(screen, self.colors[self.id], tile_rect) That’s it. The color value of the cell is obtained from the colors list using the block's ID as the index. Cool. Let’s now use this method and see a block on the screen for the first time. Back to the main.py file. First we have to import the block class. From blocks import * to import all the classes. Now let's remove the following lines of code from our main file since we used them for testing purposes only and they are not needed anymore in our final implementation. Now let’s create an LBlock. block = LBlock() Now in the game loop let’s draw this block by calling the draw method. block.draw(screen). Let’s run the game! The LBlock has appeared on the screen! How exciting! After all the code we've written, it's rewarding to finally see a block rendered on the screen. If you've made it this far, congratulations! You've accomplished the most challenging part, and things will start to progress more quickly from now on. Now, we need to create classes for the remaining 6 blocks of the game. To do this, we'll go back to the Blocks class and create a separate class for each block, such as IBlock, JBlock, SBlock, etc. For each class, we'll define the positions of the occupied cells for each rotation state, similar to what we did for the LBlock. Once we have all the block classes defined, we can easily create instances of each block type in our main program. As an exercise, take a moment to write the remaining classes yourself. I will provide you with all the data you need for each block. Simply use the same format as we did with the LBlock class and fill in the positions of the occupied cells for each rotation state. Here comes the data, pause the video for each block and fill in the data. OK, as you can now see I have completed writing the code for all subclasses. I hope it was easy for you as well. The only tricky block is the OBlock which has the same occupied cells for every rotation state and we can simply use the same list for every rotation state, or we can use just one rotation state now, and deal with it in code later. I will choose this option, let’s only leave one rotation state in its dictionary. We are ready to test all the blocks. Let’s go back to the main file and let’s draw an TBlock. Let’s change this line of code. block = TBlock() Now if we run the game, we can see the TBlock displayed! Cool! We can display all the blocks like this. Great job, we have completed step #4! We have made a lot of progress. Now let’s work on the next step. Let’s write code to move the blocks on the screen. First of all, let’s think about the problem. So far, we have created a game grid, and on top of that, we are displaying only the occupied positions of a smaller grid, the block-grid. The origin for both grids is the top left corner. So, if we want to move the block, all we have to do is to move its origin point. For example, let's say the current position of the block is at the top-left corner of the grid, which is at position (0, 0). If we want to move the block 3 columns to the right and 5 rows down, we just need two variables to hold the offset in the x and y axis on the grid. Let's call these variables 'row_offset' and 'column_offset'. To move the block 3 columns to the right and 5 rows down, we would set 'column_offset' to 3 and 'row_offset' to 5. Then, we would simply add these values to the row and column positions of the block's origin point. So, the new position of the block's origin point would be at (5, 3). This would move the block 3 columns to the right and 5 rows down on the grid. Let’s implement this in code. Let's go back to the block code. As mentioned earlier, we need to offset the positions of all cells in a block to move it. One way to do this is by adding two attributes to the block class. These attributes will hold the row and column offset of the block on the game grid. We can then update the position of each cell by adding the offset to its current position. Let’s do it. Let’s create two attributes. Let’s call the first one row_offset and set it to 0. Let’s also create the second attribute and call column_offset and set it to zero as well. Now let’s create a method that will move the block by adding a row and column offset to the cell. def move(self, rows, columns): We need to know how many rows and columns we have to move. Now all we have to do is to change the offset attributes. self.row_offset += rows Self.column_offset += columns Now we need to modify the positions of the cells in the block according to the offset. To achieve this, we can create a new method in the block class which will calculate the actual position of each cell after the offset is applied. It's better to have a separate method for this, rather than modifying the positions in the draw method, because we will need to recalculate these positions later to check for collisions. This way we can avoid repetitive calculations. So let’s create a new method called get_cell_positions() def get_cell_positions(self): This method will return the positions of the occupied cells with the offset applied in a list. First, let’s get the default cell positions for the current rotation state. tiles = self.tiles[self.rotation_state] Now, let’s create a new emty list to hold the moved tiles. Moved_tiles = [] Now we need to loop through all the tiles and add the offset to their positions For position in tiles: position = Position(position.row + self.row_offset, position.column + self.column_offset) And since we used the Position class we have to import it. So, we type at the top of the file From position import Position Now, back to the method, we just have to append the new position to the moved_tiles list. moved_tiles.append(position) And when the loop ends we have to return the list. Return moved_tiles. That’s it, our method is ready. Let’s use this method in the draw method to draw the block with the updated positions. We change this line here: tiles = self.get_cells_positions() That’s it, let’s test the game. Let’s go to the main file. We have created a block. Let’s move the block to the right 3 cells and to the bottom 4 cells. block.move(4, 3) If we now run the game we can see the block in its new position. Beautiful, we can now move the blocks of the game. But the blocks spawn at the top left corner of the grid. If we look at the online version of the Tetris game, the blocks spawn at the middle of the grid. Let’s implement that. One easy way to do this is to alter the child class for each block. So we will move each block 3 cells to the right. We can do this inside the init method of each block. So in the blocks.py file we alter all the init functions like this. self.move(0, 3) I do the same for all the blocks one after another. Now let’s go back to the main file, remove the move method call from here and let’s run the game again. As you can see the block moved to its proper position. There are only two exceptions. The first one is the OBlock. If we create an OBlock we can see it is not centered, we have to move it one cell to the right. So, we go back to the OBlock class definition and we change the move call to (0, 4). If we run the game once more, the OBlock is now centered correctly. The other exception is the I-Block. As you can see if I create an I-Block, it is centered, but there is an empty row above it. We have to move it one cell to the top. So, we go back to the IBlock class definition and we change the move call to (-1, 3). Now, if we run the game one more time, our I-Block is centered correctly. Beautiful. Moving on, we can now add input controls to move the block left and right. "But before we dive into input controls, let's take a moment to organize our code for better management and maintainability. To improve code organization and make it easier to manage in the future, we will create a Game class to hold the Grid and blcok objects, as well as various methods. The Game class will serve as a container for all the elements of our game such as the grid, current and next block, and game state. It will also hold methods that manage the game's logic such as updating the block’s position, checking for collisions, etc. By centralizing all the game's functionality within this class, it will be easier to understand, maintain, and expand upon in the future. Additionally, it will also improve code readability and reduce the risk of bugs by keeping related code together in one place. Overall, creating a Game class will greatly improve the organization and structure of our codebase, making it easier to work with in the future. So, let’s create a new Game class. We create a new file and we call it game.py. Now we type: Class Game: Def __init__(self): The game class must create and hold a grid. So let’s import the Grid class we have created. From grid import Grid Now we create a grid attribute. Self.grid = Grid() The next step is to create an attribute to hold the current block that is visible on the screen. But to do this we have to select a random block from all the available blocks in the game. So let’s first create a list of all the blocks. self.blocks = [] and now let’s create all the blocks IBlock(), JBlock(), LBlock(), OBlock(), SBlock(), TBlock(), ZBlock() Of course to use these classes we have to import them. So at the top of the file we type: From block import *, where * means everything. Now we can create a method that returns a random block from this list, so we are going to need the random module. So let’s import it as well. Import random Now let’s create the method. Def get_random_block(self): Instead of randomly selecting a block from the list every time we call the method, in the original game each of the 7 blocks appears at least once before re-appearing. So, we need to implement a way to cycle through the list of blocks ensuring that each block appears at least once before repeating the cycle. So let’s first select a random block from the list. Block = random.choice(self.block) Now we need to remove it from the list so the next time the method is called, this block will not be available. self.blocks.remove(block) Now we can return that block. Return block. Lastly, at some point, the list will become empty, meaning no more blocks will be available. In that case, we can simply refill the list with all the blocks again. So before selecting a random block we have to check if the list is empty so we type: if len(self.blocks)==0: Then we recreate the original list. Let’s copy this line from the __init__ method. Our method is ready. We can now create the two attributes for the current and the next block. In the __init__ method we type: Self.current_block = self.get_random_block() And Self.next_block = self.get_random_block() Of course the game class will also have a draw method which will be responsible for drawing all the objects on the screen. def draw(self, screen): we need to take the display surface to draw on as an argument. self.grid.draw(screen) and self.current_block.draw(screen) With this, the first version of the game class is ready! Now, let's test it out. In the main.py file, we remove all the objects we created before and the calls to draw methods of these objects in the game loop. Also, we remove these imports we no longer need them. But we have to add another import, we need the game class now. So we type: From game import Game We can now create a game object. game = Game() And in the game loop we type. game.draw(screen) That’s it. If we now run the game once more, we can see it is working like before, but our code is more readable and easier to work with as you are going to find out later. Let's move on to the next step of the game development, which is to make the player move the block. So, let’s add keyboard controls to the game. In order to control the movement of the block, we need to detect when the player presses certain keys on the keyboard. To do this, we add the following code inside the game loop: if event.type == pygame.KEYDOWN: This line of code checks if the event type is equal to the KEYDOWN constant, which means the player has pressed a key. Now, we need to determine which key the player pressed. We can do this by using the event.key attribute. This attribute returns a constant representing the key that was pressed. For example, to check if the player pressed the LEFT arrow key, we can use this if statement: if event.key == pygame.K_LEFT: This line of code checks if the event.key constant is equal to the pygame.K_LEFT constant, which represents the LEFT arrow key. If the player presses the LEFT arrow key, we have to move the block one cell to the left. We can achieve this by using the move method of the block class to move the block one column to the left. However, instead of calling the move method of the block directly, we will create a new method called move_left in the game class, as we want to encapsulate the game logic for handling the movement of the block, you are going to find out why in a minute. So, let’s go to the game class and create a new method named move_left() Def move_left(self): Now we just have to call the move method of the current block. self.current_block.move(0, -1) This way we move the block to the left. Now let’s create another method for moving the block to the right Def move_right(self): self.current_block.move(0,1). Lastly, let's create a method to move the block down. def move_down(self): self.current_block.move(1, 0) Cool. Let’s now call these methods in the main file inside the game loop. If event.key == pygame.K_LEFT: game.move_left() If event,key == pygame.K_RIGHT: game.move_right() If event,key == pygame.K_DOWN: game.move_down() Let's now run the game! It's beautiful to see our game in action, with the ability to move the block to the left, right, and down. However, we've encountered a problem - the block is able to move outside of the game window from the left, right, and bottom edges. We need to address this issue by implementing boundary checking to prevent the block from moving beyond the game window. The solution to this issue is straightforward. Since we know that the game grid contains 20 rows and 10 columns, we can simply check the current position of each tile of the block. If any of the tiles has moved outside of the game window, we need to move it back within the boundary of the game window. Let’s implement this. First of all, let’s open the grid class and add a new method in it. We are going to create a method that will check if a given tile position is inside the grid. def is_inside(self): We can pass in a row a column , row, column if row >= 0 and row < self.num_rows and column >= 0 and column < self.num_cols: Return True Return False If the position, row and column, is inside the grid we return True, else we return false. Now let’s go to the game class and add a new method that will check if a block is inside the game window using the is_inside method of the grid class we just created. Def block_inside(self): First we need to get the list of all the tiles or cells of the block. tiles = self.current_block.get_cell_positions() Now we need to check if any tile of the block is outside of the grid. For tile in tiles: If self.grid.is_inside(tile.row, tile.column) == False: If the tile is outside of the grid, return False Else Return True Our method is ready. Now we can modify the move_left, move_right and move_down methods to check if after moving the block it is still inside the game window. So, inside the move_left method we add the following code: If self.block_inside() == False: If the block moves outside of the game window we have to move it back in, so we undo the move: self.current_block.move(0, 1) We do the same for the other two methods as well. if self.block_inside() == False: self.current_block.move(0, -1) if self.block_inside() == False: self.current_block.move(-1, 0) Now we can go back to the main file and run the game once more. Perfect the game works the block cannot move outside of the game window. Keep up the good work, we're making steady progress towards completing our game! Let’s remove step #5 from the list. Moving on to the next step which will take us just a few minutes. We now need to rotate the block. Luckily since we have already entered all the data for each rotation state for each block, we don’t have a lot of work to do to rotate a block. Let’s go to the block class and create a rotate method for the block. def rotate(self): Now we simply have to increase the rotation_state by 1 Self.rotation_state += 1 We also need to check if the rotation state is equal to the number of rotation states the block has. Typically, blocks have 4 rotation states, except for the O-block which only has one. If the rotation state reaches the maximum number of states for the block, we need to reset it back to 0. We can implement this by adding a conditional check after incrementing the rotation state. if  self.rotation_state == len(self.tiles): This approach applies to all blocks in the game, including the O-block. self.rotation_state = 0 Now, we have to go to the game class and create a rotate method. def rotate(self): self.current_block.rotate() Now, in the main file, we will assign the action of pressing the up arrow key to rotating the block clockwise. In the game loop where we check for key presses we add the following: If event.key == pygame.K_UP: game.rotate() Let’s run the game! Perfect, the game works. We can move the block and we can rotate the block each time we press the up arrow key. However, there is an issue with our code. When we rotate the block, it may end up in an invalid position where some of its cells are outside the game window. This is something we need to prevent. Luckily that’s easy to fix. After rotating the block we will check if the block is inside the game window. If it is not we will undo the rotation. So first, let’s create the undo_rotation method in the block class. This method is similar to the rotate method. Def undo_rotation(self): self.rotation_state -= 1 We just set the rotation_state of the block to the previous one. The only thing we have to check is if the rotation state is 0. In that case again we will reset it. if  self.rotation_state == 0: self.rotation_state = len(self.cells) - 1 Now, we have to go to the game class and modify the rotate method to check if the block moves outside of the game window after rotating. if self.block_inside() == False: Then we have to undo the rotation, that’s easy self.current_block.undo_rotation() We are now ready to test the rotation in our game. Let’s go to the main file and run the program once more. Beautiful, the game works and the rotation works and the block cannot rotate to an invalid position, the game won’t let us. Perfect. One more step is now complete! Now, let’s work on the collisions. First we have to implement the automatic dropping of the block in a way similar to the Tetris game. To achieve this we can call the move_down() method of the game class in the game loop. This will ensure that the block gradually moves downward on its own without any user input. So after the screen.fill() call let’s add this line of code to see what happens. game.move_down() Now if we run the game we can see that the blocks drop but way fast! Why is this happening? The game loop is executed 60 times per second, so the game.move_down method is called 60 times per second. This causes the block to move 60 cells to the bottom every second, which is why it moves so quickly. Instead of calling the game.move_down() method in every execution of the game loop, we need to update it at a slower rate, for example, every 200 milliseconds. This will slow down the block’s movement and make it more visible on the screen. To achieve this, we are going to create a timer event using the pygame library. First, let's create a custom event for our game and give it a name: GAME_UPDATE = pygame.USEREVENT This line of code creates a variable GAME_UPDATE and assigns it the value of pygame.USEREVENT. USEREVENT is a special event type in pygame that can be used to create custom events. In this case, it is used to create an event that will be triggered every time the block’s position needs to be updated. Now, let's tell pygame when to trigger this custom event. We want to trigger it every 200 milliseconds. To do this, we will use the set_timer() function from the pygame.time module. pygame.time.set_timer(GAME_UPDATE, 200) This function creates a timer that will trigger the GAME_UPDATE event every 200 milliseconds. The first argument is the event that needs to be triggered and the second argument is the interval in milliseconds. In this way, we are ensuring that the game is updating the position of the block every 200 milliseconds and not 60 times per second, avoiding the problem of the block moving too fast. Now, in the game loop, as we said before, we check for any events that happened since the last time the game loop was executed. Let's add a check for our custom event. This is very simple. if event.type == GAME_UPDATE: game.move_down() This code checks if the event type is equal to GAME_UPDATE and if it is, it calls the move_down() method of the game object. This ensures that the block’s position is updated only when the GAME_UPDATE event is triggered and not every time the game loop is executed. It's important to remove the call to the game.move_down() method that was previously in the game loop, to avoid updating the snake's position more than once per interval. With this setup, let's run the game once more to see if the changes have taken effect. As you can see, the block is moving at a slower pace, which is what we want. However, we now face another issue - when the block reaches the bottom of the screen, it doesn't lock in place and we can still move it right and left. This is not the desired behavior, so let's address this problem. To fix this issue, we need to implement the locking mechanism for the block when it reaches the bottom of the game window. This will ensure that the block locks in place and becomes immovable once it reaches the bottom, in other words we have to change the grid values to hold the position of the block when it reaches the bottom of the window. So, in the game class, in the move_down() method we check if when moving down the block it gets out of the game window. In that case we undo the move. This is when we must lock the block in place. Let’s call the lock_block() method which we will create at once. self.lock_block() Now we are going to create this method. def lock_block(self): In this method, we need to update the game grid values to represent the location of each cell of the block on the grid at the time it touches the bottom of the screen. For each cell, we will store the ID of the block, in the corresponding cell on the game grid. The id value corresponds to the block's color. This will mark the cells as locked and indicate that the block has reached its final position at the bottom of the game window. First let’s get the current positions of all the tiles of the block tiles = self.current_block.get_cells_positions() Now for each cell position we will store the id of the block in the grid. for position in tiles: self.grid.grid[position.row][position.column] = self.current_block.id Now, we need to spawn a new block on the screen. We already know which is the next block, it is saved in the next_block attribute. So we type: self.current_block = self.next_block() And we have to update the next_block attribute with another random block(). Self.next_block = self.get_random_block() Let's go back to the main file and test the game once more. Now, each time a block reaches the bottom of the screen, it locks in place, and a new block is spawned. The newly spawned block cannot collide with the blocks that are already locked in place. We need to fix this problem. The solution to this is again very easy. When we move the block one row to the bottom, we need to check if the cells of the grid the block occupies are empty or not. If they are not empty we have to undo the move and lock the block in place on the grid. So, let's create a method that will check if a cell of the grid is empty or not. While we can implement this method in either the game or the grid class, it makes more sense to write it in the grid class, as it logically belongs there. In the grid class we create the method: def is_empty(self, row, column): If the cell contains the value 0 if self.grid[row][column] == 0: return True return False Great. Now in the game class, let’s create a method that will check every cell of a block to see if it is on top of an empty cell of the grid or not. Def block_fits(self): Again we get all the cells of the block: tiles = self.current_block.get_cells_positions() for tile in tiles: Now we have to check if any of the cells is occupied: if self.grid.is_empty(tile.row, tile.column) == False: In that case we have to return False Else if all the cells are empty we return True, the block can move to the specified position. The last step is to modify the move_down method. We need to check if the block after moving one row down is inside the game window or if the block fits in its new position. So we add or self.block_fits == False: here. Now, if we attempt to move the block down and encounter a cell that is already occupied, we undo the move and lock the block in place. Let’s try it in the main file. The game runs and as you can see when a block collides with another block it locks in place. It no longer overwrites it. That’s very cool. Again, we have a small problem to fix though. We check if a block collides with another block only when we move the block down, now when we move it left or right or if we rotate the block this results in a similar problem as you can see. We have to fix it. Since we now have the function needed to check if a block fits in its new position the fix to that problem is very easy. In the game class in the move_left we have to add the following check Or self.block_fits() == False. We need to check if the block after moving one column to the left is inside the game window or if the block fits in its new position. If this is False, we undo the move, it is not a valid move. We do the same thing to the move_right method. Or self.block_fits() == False And with the rotate() method: Or self.block_fits() == False That’s it. Let’s test the game once more. Good job, the game works as expected and the blocks can only move to valid positions. We can no longer overwrite the blocks that already exist on the grid. Another step is now complete. The game logic is almost ready. The next step is to check for completed rows. All we have to do is to check if a row is full, and when it is, have to clear it and move all the occupied cells above that row, one row down. This is how we are going to do it. We will scan every row of the grid from the bottom to the top. We are going to need a variable to hold the number of completed rows. If we find a completed row we will increase the completed variable by 1. Then we will clear the row and check the next row. If it is not completed, we will move the row down by the value the completed variable contains. This procedure works for any number of completed rows. See what happens if we find 2 completed rows. We check the first row, it is completed so we increase the completed variable by 1 and we clear the row. Then we check the next row. It is completed, so we increase the completed variable by 1, it is now two, and we clear the row. Next we check the next row, it is not completed, so we have to move this row down by exactly two rows. And with the same procedure we check every row of the grid. Now that we know what we have to do, let’s implement this in code. We need to write some methods in the grid class. First we need to write a method to check if a row is full. Def is_row_full(self, row). We are going to give this method a row as an argument. Now, all we have to do is check if any of the cells in a row are empty (i.e., have a value of zero). If any cell is empty, then the row is not considered full. We need to get every column of the grid for column in range(self.num_cols): Now we need to check if the value of the cell is zero if self.grid[row][column] == 0: If it is, we have to return false return False; Else we return true return True Now we need to create a method that will clear a row, in other words, it will set the value of each cell of that row to zero. Again, this method is very easy. def clear_row(self, row): Again we need the row as an argument, for column  in range(self.num_cols): Again we get all the columns self.grid[row] [column] = 0 And set the value of each cell of that row 0. Our method is ready. Now we need another method to move a row down by a specific number of rows. Def move_row_down(self, row, num_rows): Here we need two arguments, the row to move down and how many rows to move down. Again we need to get all the columns for column in range(self.num_cols): Now we need to change the values of the destination row to be equal to the current row. self.grid[row+num_rows] [column] = self.grid[row][column] Lastly we have to clear the current row. self.grid[row][column] = 0 In summary, this code moves a row in the grid down by num_rows rows by copying the values from the original row to a new row and clearing the original row. We are now ready to create the method that will combine all these methods. Def clear_full_rows(self): This method will check all the rows from the bottom to the top to see if any row is completed. So we need a completed variable. completed = 0 Now we need to check every row, starting from row 19 and moving down to row 0 for row in range(self.num_rows-1, 0, -1): This for loop iterates through the rows of the grid in reverse order, starting from the last row and going up to the first row (row 0), with a step of -1 to move upward. Now we have to check if the current row is full using the is_row_full method, we wrote earlier if self.is_row_full(row): If the row is full we have to Call the clear_row method to clear all the cells in the current row. self.clear_row(row) Then we have to Increment the completed counter by 1 to keep track of the number of rows completed. completed += 1 Now If the current row is not full, but some rows have already been cleared, it means we have to move that row down. elif completed > 0: self.move_row_down(row, completed) Lastly, let's return the completed rows, we will need them to calculate the score later on. Return completed. Great, now we are ready to use that newly created function in our game. We have to go to the game class and in the lock_block method we have to call the clear_full_rows() method. self.grid.clear_full_rows() here. Let’s navigate back to the main file and then run the game once more. Now each time we complete a row, it should disappear from the grid. OK, let me place some blocks on the grid. Here we go. A completed row, it goes away. Perfect. Another very important step of the game is now complete! Let’s work on the next step, which is to make the game end. The game ends when a newly spawned block overlaps with a block that is already locked in place on the grid, preventing further movement or placement of the new block. In our game, the new block is spawned at the top of the screen, similar to the online version of Tetris. However, in some other versions of Tetris, the new block is spawned outside of the visible screen and then gradually slides into the play area, one row at a time. So to check if the game has to end, all we have to do is to check if the newly created block fits in the grid. If it does not “fit” the game is over. So, let’s code this behaviour in the game class. That’s easy. When we lock a block in the grid we create a new block. Now we have to check if that new block fits in the grid. if self.block_fits() == False: If the block does not fit we have to end the game. Let’s create a game_over attribute to the game class and set it to false. At the init method we type: Self.game_over = False. Now we need to set this attribute to True when the game ends. So, in the lock_block method, if the block does not fit, we set the game_over attribute to True. The last thing we have to do, is to stop the game from updating every 200ms if the game is over and don’t let the user move the block if the game is over. So, in the main file, we add this check here. And game.game_over == False Which means the game will only update if it is not over. We do the same thing with the movement and rotation of the blocks, here, …. Here …. Here ,,,,, and here… Perfect, let’s run the game with the new functionality, with increased game speed to check for the game over condition. As you can see, when the new block spawns on top of an occupied cell, the game immediately ends, and the player is no longer able to move the block. But, so far there is no way to restart the game after it is over. That’s what we are going to work on now. Let’s modify the main file to restart the game whenever a key on the keyboard is pressed. In the game loop, where we check for key presses we have to add this check: if game.game_over == True: The game is over and a key is pressed, we need to restart the game, so we have to set the game_over attribute to False game.game_over = False And we have to reset the game. Let’s call a reset method. game.reset() We haven’t created a reset method in the game class, let’s create it now. In the game class we type: Def reset(self): What do we need to do? We have to clear the grid. self.grid.reset() But we don’t have a reset method for the grid class. Let’s create one. We go to the grid class and we create a new method. Def reset(self): Now we need to loop through all the cells and set their value to zero. for row in range(self.num_rows): for column in range(self.num_cols) self.grid[row][column] = 0 It is now time to call this method from the game class. Inside the reset method we type. self.grid.reset(). OK, the grid is now reset. What do we have to do when the game ends? We need to select a new random current_block from the list of blocks, and a new next_block. But first we have to create a new list with all the blocks. Again we copy this line of code which creates a list of all the blocks from the init method. self.blocks = [IBlock(), JBlock(), LBlock(), OBlock(), SBlock(), TBlock(), ZBlock()] And then we select a random block to be the current block and another one to be the next block. self.current_block = self.get_random_block() self.next_block = self.get_random_block() Let’s run the game one more time. Let me drop some blocks quickly to see what happens. Perfect, as you can see, the game is now over and it waits for a key press. If I press any key on the keyboard, the game starts over with a clear grid. Very cool! Congratulations! You've successfully implemented the game logic. Well done on reaching this point! Another step is now complete. Now let’s work on the next step, let’s add a User Interface to the game to look like this. The user interface consists of several components: A background rectangle that serves as the canvas on which all the game elements are drawn. A title text element for displaying the score. A rounded rectangle to display the score value. A text element for rendering the actual score value. A title text element for displaying the upcoming shape (next shape). A rounded rectangle to display the next shape. The actual next block shape itself. A title text element for displaying the "Game Over" message. These elements work together to create the visual interface for the game, providing information on the score, the next shape, and the game over condition. Let’s start by creating the background. First, let’s make the game update slower once again, by changing this value to 200. Now, the following line of code creates the display surface, which serves as the canvas on which we draw all the game elements. The game window is sized to match the dimensions of the grid. Let's give the grid an offset of 10 pixels to the left, top, and bottom, and 210 pixels to the right. The new dimensions of the display surface will be 500, 620. If we run the game now, we can see that the grid is drawn from the top left corner of the game window without any offset. Let's give it a 10-pixel offset to align it properly. To properly align the grid within the game window, we need to make a change in the draw method of the Grid class. We can adjust the x and y coordinates of the rectangle being drawn by adding 10 pixels to both. So, we can update the expression "1 +" to "11 +" in order to achieve the desired offset. Similarly, we need to update the draw method of the Block class to add 10 pixels to the x and y coordinates of the cell being drawn. This can be achieved by modifying the line to look like this: +11 here and here. Cool, let's run the game one more time. Perfect as you can see, the background of the game is now visible. Now moving on to the next ui element, we need to print the text Score on the Screen. ------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------ In pygame to create and display some text we need to follow three steps. First we need to create a font, then a surface with the text we want to display, and then we can display that surface using the blit method of the display surface object. First let’s draw the Score title. So, outside of the game loop, below the pygame.init() call let’s create a font and call it title_font. title_font = pygame.font.Font() and we have to give it a font family and a size. For the font family I will enter None so it will use the default font of the pygame module. For the size of the font I give it the value 40. The first step is done. Now we have to create a surface for the title.To do this we use the render method from our title_font object. score_surface = title_font.render() We pass in the string that we want to display, “Score” we set the anti-alias argument to true and finally we set the color of the font. I’m going to set it to white. White is a tuple with the values (255, 255, 255) So let’s store this value in the Colors class as well. So, we open the Colors class and we add the white color definition as well. Also, now that we work on the Color Class let’s add the dark blue color definition for the game background as well. We cut it from the main file and we paste it in the Colors class. Lastly I am going to add another color that we are going to need in a minute, light_blue = (59, 85, 162) Now back to the main file, We have to import the colors class From colors import Colors Then in the game loop here we have to change this line like this: Color.dark_blue And inside the render call, we change this tuple to Colors.white. This way, it is more readable, and we define all the colors in just one place. Now we can call the blit method to display the score_surface on the display_surface which we have named screen. Blit means block image transfer. Most of the time in pygame we are going to be blitting images to the display_surface . We will call the blit method inside the game loop. We have to pass in the surface that we want to display and the location on the screen. So we type: screen.blit(score_surface and the position we want it to be in a tuple, let say (365, 20, 50, 50) Let’s run the game! Cool! The score title appeared in its position. Now let’s add a rounded rectangle of light_blue color to draw the score on. To draw a rectangle we first need to create a rectangle object. Let’s create it here, outside of the game loop. score_rect = pygame.Rect() We need the x and y coordinate of its top left corner, let’s enter 320, 55 for the x and y and we need the width and the height of the rectangle. Let’s enter 170, 60. The rectangle is ready. Let’s print it on the screen. In the game loop we are going to call the pygame.draw.rect() method. pygame.draw.rect(screen, Now we need a light blue color. So Colors.light_blue, and now we type, 0, 10) to make the rectangle have rounded corners. If we run the game now, we can see that a new rounded rectangle appear on the screen. Perfect. With the same procedure we are going to create the title Next and the rounded rectangle below it. Again outside of the game loop we create a surface for the title next using the same font, the title font. We can re-use the same font because we want all the titles to be identical in font family and font size. So we type next_surface = title_font.render("Next", True, Colors.white) And now we have to display that surface with the blit method inside the game loop. screen.blit(next_surface, ()) and now we need a tuple with the position on the screen. We will enter these values: (375, 180, 50, 50) Upon running the game again, you will now see the newly added title text on the screen, which is a great addition to the user interface. The next step is to draw a rectangle below the title Next to display the Next shape. Again we are going to create rectangle, let’s name it next_rectangle = pygame.Rect(320, 215, 170, 180) And now we can display it on the screen, so in the game loop we type: pygame.draw.rect(screen, Colors.light_blue, next_rect, 0, 10) Perfect. If we run the game we can see the new rectangle displayed. Now the last thing we have to do is to display a game over message when the game is over and the basic UI elements will be ready. Again we are going to use the same font. So outside of the game loop we are going to create a new surface like this: game_over_surface = title_font.render("GAME OVER", True, Colors.white) And now in the game loop we have to display it. screen.blit(game_over_surface, (320, 450, 50, 50)) Let’s see if this works and then we will update our code to display this text only if the game is over. Beautiful, the GAME_OVER message appears on the screen. We can implement a simple check in the game loop, just before drawing the game over message, to ensure that the message is only shown when the game is actually over. if game.game_over == True: and then we have to indent this line to belong to the if statement. That’s it. Let’s test the game. Beautiful, the game works fine and the Game Over message does not appear unless the game is over. When we press any key, the game restarts and the message disappears. With that, another step is now complete. Well done! We are now very close to completing the game. Keep up the good work! The next step is to add scoring to the game and display it on the screen. However, it's important to note that our version of the game is a simplified version of Tetris, and does not include all the features of the original game for the sake of simplicity. Therefore, the scoring system will also be limited in our implementation. In our simplified version of Tetris, the player will earn points for clearing lines and moving the block down. Specifically, we can assign the following point values to different actions: 100 points for a single line clear 300 points for a double line clear 500 points for a triple line clear 1 point for each block move down by the player To implement this scoring system, we will need to add a score attribute to our game class. So in our game class, in the init method we add Self.score = 0 Now let’s create a method that will be responsible for updating the score of the game. Def update_score() we need to know two things: the number of lines cleared and the number of times the player moved a block down. So we need two arguments (self, lines_cleared, move_down_points) Now we need an if statement to award points according to how many lines the player has cleared. if lines_cleared == 1: self.score += 100 elif lines_cleared == 2: self.score += 300 elif lines_cleared == 3: self.score += 500 Lastly we need to add one point each time the player moves the block down. self.score += move_down_points That’s it. Our method is ready. Let’s call it. The first place where we need to call it is inside the lock_block method where we clear the rows using the clear_full_rows() method of the grid class. This method returns the number of rows cleared so we can save this information in a variable, let’s call it rows_cleared. Now we need to call the update score method and pass in this variable as an argument. self.update_score(rows_cleared, 0) Now we need to increase the score when the player moves the block down. We have to do this in the main file. But before we leave this file, let’s reset the score to zero when we reset the game. In the reset method we type: Self.score = 0 In the main file now, In the game loop where we check for user input we have to call the update_score method when the user presses the down key. game.update_score(0, 1) That’s it. Now we need to display the text on the screen. We will use the same font object we used for the other text we displayed on the screen. Again, we will create a surface for the score, but this time we will create the surface for the score inside the game loop. Can you think of a reason why? Take a moment to consider it. I'll wait. The score is dynamic and changes throughout the game as the player clears lines and moves the block. That's why we need to create a new surface for the score each time we want to update and display it on the screen. It is not a static text. So inside the game loop we create the score_surface score_surface = title_font.render(str(game.score), True, Colors.white) The score is an integer, so we need to convert it to a string before displaying it, that’s why we call the str() method here. Now let’s display that surface on top of the score_rect. So, we type this AFTER the line that draws the score_rect on the screen. screen.blit(score_value surface, ) Now we need to define the position on the screen where we want to draw the text. This is tricky, because the score is not static, its size will change. If we want it to be centered, we can use a small trick. Check this out. score_value_surface.get_rect(centerx=score_rect.centerx, centery=score_rect.centery) This code calculates the rectangle that encloses the score_value_surface text, and centers it on the score_rect horizontally and vertically, so that the score is displayed in the middle of the score_rect. Perfect. Let’s run the game! Amazing stuff! The score is now displayed on the screen. Each time I move a block down, the score increases. Let me show you what happens if I complete a row. Give me a second to achieve it. The score increased by 100 points. Beautiful. Our scoring system works. Another step is now complete. We are now just two steps away from completing our Tetris game. The next step is to draw the next block on the screen. This step is relatively easy to implement thanks to the use of Object-Oriented Programming (OOP) principles in our game design. We will work on the block class. We already have a draw method that draws a block on the screen. We will reuse the same draw method. We need to draw the block, but at another position, so we need an offset. So we will add two arguments to the method. An offset_x and an offset_y arguments. Now in this line where we create the Rectangle to draw on the screen we need to add offset_x + here, and offset_y + here. Also we can remove the +11 from here and here since we now have arguments for the offset. The draw method is ready. Let’s now go to the game class. In the draw() method we draw the current block. We need to modify the method to add the offset_x and offset_y values. We add ,11 ,11 here. It is the hardcoded offset we removed from the draw method. Now all we have to do is draw the next_block on the screen. self.next_block.draw(screen, and let’s enter 270, 270) Let’s run the game. Beautiful! As you can see, the next block appeared on top of the next rectangle. Cool. You can see that the block changes each time I place a block on the grid. But there is something that bothers me. The IBlock and the OBlock are not centered in the rectangle. I have to fix it. So, let’s go back to the game class. In the draw method we have to check the id of the next_block before it is drawn on the screen. if self.next_block.id == 3: //That’s the IBlock Give this block its own offset values self.next_block.draw(screen, 255, 290) elif self.next_block.id == 4: //That’s the OBLOck self.next_block.draw(screen, 255, 280) Else: // all the other blocks work OK with the default offset self.next_block.draw(screen, 270, 270) It is not an elegant solution, but it works. Great job! Running the game again, we can now see that the blocks are appearing centered on the rectangle. This is a significant progress, and another step towards completing our game. Now let’s add sounds to the game. Sounds are important to a game as they provide feedback, create atmosphere, evoke emotions, and contribute to the identity of the game. Due to copyright reasons, I won't be using the original Tetris soundtrack for the game. Instead, I will be using a theme created by my friend Spyros specifically for this video. The sound files are included in the GitHub repository of the game. You can find more amazing music by Spyros in a link provided in the video description. Now, in my game folder, I have created a new folder named 'Sounds' and placed three sound files in it. One is named 'music.ogg’ which contains the background music for our game, and the other two are 'rotate.ogg and 'clear.ogg which contain sound effects for rotation and clearing rows respectively. Pygame supports various sound file formats including .mp3, but due to some known issues with .mp3 support, I opted to use the .ogg format. First, we need to start playing the background music when the game starts, and ensure that the music loops continuously as long as the player is actively playing the game. We can do this either in the main file or in the game glass. Let’s implement it in the game class. First, we need to import the pygame module in this class, since we haven't done so yet. Import pygame Now we have to load the music. In the init function of the game class we add this line of code: pygame.mixer.music.load() and now we have to add the file we want to load in quotes ‘Sounds/music.ogg’ The next step is to play the music. We have to use this line of code: pygame.mixer.music.play(-1) This line of code plays the background music using pygame.mixer.music module, with the argument -1 indicating that the music should loop indefinitely. Let’s test it. Perfect! We can hear the music of the game. Now all we have to do is to add sounds for rotating and for clearing a row. We go back to the game class and we add two attributes in the init method. Let’s name the first one rotate_sound Self.rotate_sound = Now we have to load the sound. pygame.mixer.Sound() and now have to enter the file name in quotes. ‘Sounds/rotate.ogg’) We do the same thing for the clear sound. self.clear_sound = pygame.mixer.Sound('Sounds/clear.ogg') All the sounds are now loaded and ready to play. All we have to do now is to call the play() method of each sound when we need to. Let’s work on the rotate sound first. We need to play this sound when we rotate the block. So in the rotate method of the game class we have to add a call to the play method. Here we check if the rotation is not valid: If the rotation is valid we need to play a sound so we add: Else: self.rotate_sound.play() Cool. Now we have to play the clear sound when we clear some rows. In the lock_block method we call the clear_full_rows() method which returns the number of rows cleared. If the number is greater than 0 we have to play the clear sound. So let’s add a check: If rows_cleared > 0: self.clear_sound.play() We can also add the update_score method inside the if statement now that we have that check in place, the player will be awarded points only if has cleared a row, so we don’t need to call this method every time the user places a block. Believe it or not with that change our game is ready! Let’s test it out. Our game is ready, the music is playing, the sounds are playing, the score is updating and in general the game works as expected. Congratulations on finishing the Tetris tutorial! You worked really hard and learned a lot about making games. By creating this classic game, you improved your skills and gained valuable experience that will help you in your future projects. Be proud of yourself and keep up the good work! To further your knowledge and continue learning, be sure to subscribe to our channel for more tutorials like this one. We will keep you updated with new and exciting projects that you can work on to enhance your skills. Thank you very much for watching this video, I will see you next time.